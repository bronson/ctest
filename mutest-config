#!/usr/bin/perl -w

# mutest-config
# Scott Bronson
# 5 Mar 2007

# This file is copyright (C) 2007 Scott Bronson
# It is released under the MIT license.
#
# mutest-config outputs the files required to compile the specified
# flavor of mutest.
#
# This allows the mutest project to rename and remove support files
# without causing breakage.  (we're not too worried about
# files like 'mu_assert.h" which the user must #include anyway.
# we're worried about being able to refactor support files
# without breaking everyone's build scripts -- a surprisingly
# common occurrence)
#
#   -c: output C files required to compile the given assert flavor(s)
#   -h: output header files required to compile the given assert flavor(s)
#   -t: output header files
#   -p mu: prefix to add to file paths: "mu/f1.c mu/f2.c" etc.
#      (by default, mutest-config adds the prefix that it was called
#      with.  i.e. if you called 'mutest/mutest-config', it would
#      add 'mutest/' in front of each file.  Use -p "" to force no
#      prefix)
#
# If you don't specify one or more flavor, files for all flavors will
# be produced.

use strict;
use Getopt::Long ();
use File::Basename ();


sub usage() {
	die "Usage: $0 [-c] [-h] [-t] [flavors...]\n";
}


# All files that can be produced, grouped by type and flavor.
my $per_flavor_files = {
	default => {
		c => ['mutest.c'],
		h => ['mutest.h', 'mutest_test.h'],
	},
	assert => {
		h => ['mu_assert.h'],
		t => ['test_assert.c'],
	},
};

# parse command line arguments
my $prefix = File::Basename::dirname($0);
my @opts = ();
usage() unless Getopt::Long::GetOptions(
	"cfiles|c" => sub { push @opts, "c" },
	"headers|h" => sub { push @opts, "h" },
	"tests|t" => sub { push @opts, "t" },
	"prefix|p=s" => \$prefix,
);
die "You must specify some combination of -c -h or -t\n" unless @opts;

# suppress a redundant "./" on the front of each file
$prefix = "" if $prefix eq ".";

# Output files for all flavors if user didn't specify a flavor
@ARGV = keys %$per_flavor_files unless @ARGV;

# Discover what files are required 
my $result_files = {};
get_result_files($per_flavor_files->{'default'}, @opts);
for my $flavor (@ARGV) {
	if($per_flavor_files->{$flavor}) {
		get_result_files($per_flavor_files->{$flavor}, @opts);
	} else {
		die "Unknown flavor $flavor\n";
	}
}

die "No files returned?!" unless %$result_files;

# output files grouped by extension, ordered alphabetically
print join(" ",(result_list('c'), result_list('h'), result_list('t')))."\n";
exit 0;


sub get_result_files
{
	my $files = shift;

	for my $type (@_) {
		if(exists $files->{$type}) {
			for my $file (@{$files->{$type}}) {
				$result_files->{$file} = $type;
			}
		} else {
			# no files are required for this flavor and type.
		}
	}
}


sub result_list
{
	my $type = shift;

	return map { $prefix ne "" ? "$prefix/$_" : $_ }
		sort grep { $result_files->{$_} eq $type }
			keys %$result_files;
}

